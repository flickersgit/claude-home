<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Retro Racing</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Courier New', monospace;
    overflow: hidden;
  }
  #gameContainer {
    position: relative;
    border: 4px solid #33ff33;
    box-shadow: 0 0 30px rgba(51,255,51,0.3), inset 0 0 30px rgba(51,255,51,0.05);
    image-rendering: pixelated;
  }
  canvas { display: block; touch-action: none; }
  #overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.85);
    z-index: 10;
    transition: opacity 0.3s;
  }
  #overlay.hidden { opacity: 0; pointer-events: none; }
  #overlay h1 {
    font-size: 48px; color: #ff3333; text-shadow: 3px 3px 0 #880000;
    letter-spacing: 6px; margin-bottom: 10px;
    animation: pulse 1.5s ease-in-out infinite;
  }
  #overlay h2 {
    font-size: 18px; color: #ffcc00; margin-bottom: 30px; letter-spacing: 2px;
  }
  #overlay .info {
    font-size: 14px; color: #33ff33; margin: 5px 0; letter-spacing: 1px;
  }
  #overlay .start-btn {
    margin-top: 30px; padding: 15px 50px; font-size: 20px;
    font-family: 'Courier New', monospace; font-weight: bold;
    background: transparent; color: #33ff33;
    border: 3px solid #33ff33; cursor: pointer;
    letter-spacing: 4px; text-transform: uppercase;
    transition: all 0.2s;
    min-width: 200px; min-height: 56px;
    touch-action: manipulation;
  }
  #overlay .start-btn:hover {
    background: #33ff33; color: #000;
    box-shadow: 0 0 20px rgba(51,255,51,0.5);
  }
  #overlay .score-display {
    font-size: 28px; color: #ff3333; margin: 15px 0;
    text-shadow: 2px 2px 0 #880000;
  }
  #hud {
    position: absolute; top: 10px; left: 0; width: 100%;
    display: flex; justify-content: space-between; padding: 0 15px;
    z-index: 5; pointer-events: none;
  }
  #hud span {
    font-size: 16px; color: #fff; text-shadow: 1px 1px 0 #000;
    letter-spacing: 2px;
  }
  #hud .speed { color: #ffcc00; }
  #hud .score { color: #33ff33; }
  #hud .lives { color: #ff3333; }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }
  #mobileControls {
    position: absolute; bottom: 20px; left: 0; width: 100%;
    display: none; justify-content: space-between; align-items: flex-end;
    padding: 0 16px;
    z-index: 5;
  }
  .mBtn-group {
    display: flex; gap: 10px;
  }
  .mBtn-group.vertical {
    flex-direction: column;
  }
  .mBtn {
    width: 80px; height: 80px; border-radius: 50%;
    background: rgba(51,255,51,0.15); border: 2px solid rgba(51,255,51,0.4);
    color: #33ff33; font-size: 30px; display: flex;
    justify-content: center; align-items: center;
    user-select: none; -webkit-user-select: none;
    touch-action: none;
  }
  .mBtn:active { background: rgba(51,255,51,0.35); }
  @media (pointer: coarse) {
    #mobileControls { display: flex; }
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div id="hud">
    <span class="score">SCORE: <span id="scoreVal">0</span></span>
    <span class="speed">SPD: <span id="speedVal">0</span> KM/H</span>
    <span class="lives">LIVES: <span id="livesVal">3</span></span>
  </div>
  <div id="overlay">
    <h1>RETRO RACING</h1>
    <h2>TURBO EDITION</h2>
    <div class="info">Arrow Keys / WASD to steer</div>
    <div class="info">Hold UP to accelerate</div>
    <div class="info">Avoid traffic & collect fuel</div>
    <button class="start-btn" id="startBtn">START</button>
  </div>
  <div id="mobileControls">
    <div class="mBtn-group">
      <div class="mBtn" id="btnLeft">&#9664;</div>
      <div class="mBtn" id="btnRight">&#9654;</div>
    </div>
    <div class="mBtn-group vertical">
      <div class="mBtn" id="btnUp">&#9650;</div>
      <div class="mBtn" id="btnDown">&#9660;</div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = 480, H = 700;
canvas.width = W;
canvas.height = H;

const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const scoreVal = document.getElementById('scoreVal');
const speedVal = document.getElementById('speedVal');
const livesVal = document.getElementById('livesVal');

// Game state
let state = 'menu'; // menu, playing, gameover
let score = 0;
let lives = 3;
let speed = 0;
let maxSpeed = 12;
let roadOffset = 0;
let frameCount = 0;
let difficulty = 1;
let shakeTimer = 0;
let flashTimer = 0;
let invincibleTimer = 0;
let combo = 0;
let comboTimer = 0;
let particles = [];
let sparks = [];
let textPopups = [];
let nightMode = false;
let nightTimer = 0;

// Road config
const roadLeft = 90;
const roadRight = 390;
const roadCenter = (roadLeft + roadRight) / 2;
const laneWidth = (roadRight - roadLeft) / 3;
const lanes = [
  roadLeft + laneWidth * 0.5,
  roadLeft + laneWidth * 1.5,
  roadLeft + laneWidth * 2.5
];

// Player
const player = {
  x: roadCenter,
  y: H - 140,
  w: 36,
  h: 60,
  vx: 0,
  targetX: roadCenter,
  tilt: 0
};

// Input
const keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key] = false; });

// Mobile controls
function setupMobile(id, key) {
  const el = document.getElementById(id);
  el.addEventListener('touchstart', e => { e.preventDefault(); keys[key] = true; });
  el.addEventListener('touchend', e => { e.preventDefault(); keys[key] = false; });
}
setupMobile('btnLeft', 'ArrowLeft');
setupMobile('btnRight', 'ArrowRight');
setupMobile('btnUp', 'ArrowUp');
setupMobile('btnDown', 'ArrowDown');

// Enemies
let enemies = [];
const carColors = [
  ['#ff4444','#cc2222','#881111'],
  ['#4444ff','#2222cc','#111188'],
  ['#ffaa00','#cc8800','#886600'],
  ['#ff44ff','#cc22cc','#881188'],
  ['#44ffff','#22cccc','#118888'],
  ['#ffffff','#cccccc','#888888'],
  ['#88ff44','#66cc22','#448811']
];

// Fuel pickups
let fuels = [];

// Trees/scenery
let scenery = [];
for (let i = 0; i < 20; i++) {
  scenery.push({
    x: Math.random() < 0.5 ? Math.random() * 70 : roadRight + 20 + Math.random() * 70,
    y: Math.random() * H,
    type: Math.floor(Math.random() * 3),
    size: 0.6 + Math.random() * 0.6
  });
}

function spawnEnemy() {
  const lane = Math.floor(Math.random() * 3);
  const colorSet = carColors[Math.floor(Math.random() * carColors.length)];
  const isTruck = Math.random() < 0.2;
  enemies.push({
    x: lanes[lane],
    y: -80,
    w: isTruck ? 40 : 34,
    h: isTruck ? 80 : 58,
    speed: 2 + Math.random() * 2,
    colors: colorSet,
    isTruck: isTruck,
    lane: lane
  });
}

function spawnFuel() {
  const lane = Math.floor(Math.random() * 3);
  fuels.push({
    x: lanes[lane],
    y: -30,
    w: 20, h: 24,
    bobble: Math.random() * Math.PI * 2
  });
}

function addParticle(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 2,
      life: 30 + Math.random() * 20,
      maxLife: 50,
      color: color,
      size: 2 + Math.random() * 4
    });
  }
}

function addSpark(x, y) {
  for (let i = 0; i < 6; i++) {
    sparks.push({
      x, y,
      vx: (Math.random() - 0.5) * 10,
      vy: (Math.random() - 0.5) * 10,
      life: 15 + Math.random() * 10,
      maxLife: 25
    });
  }
}

function addTextPopup(x, y, text, color) {
  textPopups.push({ x, y, text, color, life: 50, maxLife: 50 });
}

// Draw pixel car
function drawCar(x, y, w, h, colors, isTruck, isPlayer) {
  ctx.save();
  ctx.translate(x, y);

  if (isPlayer) {
    ctx.rotate(player.tilt * 0.04);
  }

  const hw = w / 2, hh = h / 2;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(-hw + 3, -hh + 3, w, h);

  // Body
  ctx.fillStyle = colors[0];
  ctx.fillRect(-hw, -hh, w, h);

  // Darker sides
  ctx.fillStyle = colors[1];
  ctx.fillRect(-hw, -hh, 4, h);
  ctx.fillRect(hw - 4, -hh, 4, h);

  // Windshield
  ctx.fillStyle = isPlayer ? '#66ccff' : '#334455';
  if (isPlayer) {
    ctx.fillRect(-hw + 6, -hh + 10, w - 12, 14);
    // Rear window
    ctx.fillStyle = '#4499cc';
    ctx.fillRect(-hw + 8, hh - 20, w - 16, 10);
  } else {
    ctx.fillRect(-hw + 5, hh - 18, w - 10, 12);
    if (isTruck) {
      ctx.fillStyle = colors[2];
      ctx.fillRect(-hw + 2, -hh, w - 4, h * 0.55);
    }
  }

  // Headlights / taillights
  if (isPlayer) {
    ctx.fillStyle = '#ffff66';
    ctx.fillRect(-hw + 2, -hh, 8, 6);
    ctx.fillRect(hw - 10, -hh, 8, 6);
    // Glow
    ctx.fillStyle = 'rgba(255,255,100,0.15)';
    ctx.beginPath();
    ctx.moveTo(-hw + 2, -hh);
    ctx.lineTo(-hw - 10, -hh - 40);
    ctx.lineTo(hw - 2 + 10, -hh - 40);
    ctx.lineTo(hw - 2, -hh);
    ctx.fill();
    // Tail lights
    ctx.fillStyle = '#ff2222';
    ctx.fillRect(-hw + 2, hh - 6, 8, 6);
    ctx.fillRect(hw - 10, hh - 6, 8, 6);
    // Stripe
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(-3, -hh, 6, h);
  } else {
    ctx.fillStyle = '#ff4444';
    ctx.fillRect(-hw + 3, -hh, 6, 5);
    ctx.fillRect(hw - 9, -hh, 6, 5);
  }

  // Exhaust particles for player
  if (isPlayer && state === 'playing' && speed > 2) {
    if (frameCount % 3 === 0) {
      addParticle(x - 8, y + hh + 5, '#888', 1);
      addParticle(x + 8, y + hh + 5, '#888', 1);
    }
  }

  ctx.restore();
}

function drawFuel(f) {
  const bob = Math.sin(f.bobble) * 3;
  const x = f.x, y = f.y + bob;
  // Canister
  ctx.fillStyle = '#33ff33';
  ctx.fillRect(x - 8, y - 10, 16, 20);
  ctx.fillStyle = '#22aa22';
  ctx.fillRect(x - 8, y - 10, 4, 20);
  // Cap
  ctx.fillStyle = '#ffcc00';
  ctx.fillRect(x - 4, y - 14, 8, 6);
  // F label
  ctx.fillStyle = '#004400';
  ctx.font = 'bold 10px Courier New';
  ctx.textAlign = 'center';
  ctx.fillText('F', x + 1, y + 5);
  // Glow
  ctx.fillStyle = 'rgba(51,255,51,0.1)';
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2);
  ctx.fill();
}

function drawSceneryItem(s) {
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.scale(s.size, s.size);

  if (s.type === 0) {
    // Tree
    ctx.fillStyle = '#2d5a1e';
    ctx.beginPath();
    ctx.moveTo(0, -25);
    ctx.lineTo(-12, 5);
    ctx.lineTo(12, 5);
    ctx.fill();
    ctx.fillStyle = '#1a3a10';
    ctx.beginPath();
    ctx.moveTo(0, -15);
    ctx.lineTo(-10, 10);
    ctx.lineTo(10, 10);
    ctx.fill();
    ctx.fillStyle = '#5a3a1e';
    ctx.fillRect(-3, 5, 6, 10);
  } else if (s.type === 1) {
    // Bush
    ctx.fillStyle = '#2a6a1a';
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1e4a12';
    ctx.beginPath();
    ctx.arc(5, -2, 7, 0, Math.PI * 2);
    ctx.fill();
  } else {
    // Rock
    ctx.fillStyle = '#666';
    ctx.beginPath();
    ctx.moveTo(-8, 5);
    ctx.lineTo(-6, -6);
    ctx.lineTo(4, -8);
    ctx.lineTo(10, 0);
    ctx.lineTo(6, 6);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(-5, -3);
    ctx.lineTo(2, -6);
    ctx.lineTo(7, -1);
    ctx.lineTo(0, 1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

function drawRoad() {
  // Grass
  const grassColor = nightMode ? '#0a2a0a' : '#1a5a1a';
  const grassColor2 = nightMode ? '#0d300d' : '#1e6a1e';
  ctx.fillStyle = grassColor;
  ctx.fillRect(0, 0, W, H);

  // Grass stripe pattern
  for (let gy = (roadOffset * 0.3) % 20 - 20; gy < H; gy += 20) {
    ctx.fillStyle = grassColor2;
    ctx.fillRect(0, gy, roadLeft, 10);
    ctx.fillRect(roadRight, gy, W - roadRight, 10);
  }

  // Road surface
  ctx.fillStyle = nightMode ? '#1a1a1a' : '#333';
  ctx.fillRect(roadLeft, 0, roadRight - roadLeft, H);

  // Road texture
  ctx.fillStyle = nightMode ? '#1f1f1f' : '#3a3a3a';
  for (let ry = (roadOffset * 0.5) % 8 - 8; ry < H; ry += 8) {
    ctx.fillRect(roadLeft, ry, roadRight - roadLeft, 2);
  }

  // Lane markings
  const dashLen = 40, gapLen = 30;
  ctx.fillStyle = '#ffcc00';
  for (let i = 1; i < 3; i++) {
    const lx = roadLeft + laneWidth * i;
    for (let dy = (roadOffset % (dashLen + gapLen)) - dashLen; dy < H; dy += dashLen + gapLen) {
      ctx.fillRect(lx - 2, dy, 4, dashLen);
    }
  }

  // Road edges (rumble strips)
  const rumbleSize = 20;
  for (let ry = (roadOffset % (rumbleSize * 2)) - rumbleSize * 2; ry < H; ry += rumbleSize * 2) {
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(roadLeft - 8, ry, 8, rumbleSize);
    ctx.fillRect(roadRight, ry, 8, rumbleSize);
    ctx.fillStyle = '#fff';
    ctx.fillRect(roadLeft - 8, ry + rumbleSize, 8, rumbleSize);
    ctx.fillRect(roadRight, ry + rumbleSize, 8, rumbleSize);
  }

  // Curb lines
  ctx.fillStyle = '#fff';
  ctx.fillRect(roadLeft - 2, 0, 2, H);
  ctx.fillRect(roadRight, 0, 2, H);
}

function drawStartLine() {
  // Start/finish line pattern at bottom
  const sy = H - 40;
  for (let sx = roadLeft; sx < roadRight; sx += 20) {
    const checker = ((sx - roadLeft) / 20) % 2 === 0;
    ctx.fillStyle = checker ? '#fff' : '#000';
    ctx.fillRect(sx, sy, 20, 10);
    ctx.fillStyle = checker ? '#000' : '#fff';
    ctx.fillRect(sx, sy + 10, 20, 10);
  }
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;

  sparks.forEach(s => {
    const alpha = s.life / s.maxLife;
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#ffff44';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x - s.vx * 2, s.y - s.vy * 2);
    ctx.stroke();
  });
  ctx.globalAlpha = 1;
}

function drawTextPopups() {
  textPopups.forEach(t => {
    const alpha = t.life / t.maxLife;
    const rise = (t.maxLife - t.life) * 0.8;
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 18px Courier New';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#000';
    ctx.fillText(t.text, t.x + 1, t.y - rise + 1);
    ctx.fillStyle = t.color;
    ctx.fillText(t.text, t.x, t.y - rise);
  });
  ctx.globalAlpha = 1;
}

function drawNightOverlay() {
  if (!nightMode) return;
  // Darken edges
  const grad = ctx.createRadialGradient(player.x, player.y - 40, 80, player.x, player.y - 40, 300);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(1, 'rgba(0,0,0,0.6)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
}

function drawSpeedLines() {
  if (speed < 6) return;
  const intensity = (speed - 6) / (maxSpeed - 6);
  ctx.globalAlpha = intensity * 0.3;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  for (let i = 0; i < 8; i++) {
    const sx = roadLeft + Math.random() * (roadRight - roadLeft);
    const sy = Math.random() * H;
    const len = 20 + speed * 4;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx, sy + len);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawMinimap() {
  const mx = W - 55, my = 50, mw = 40, mh = 120;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(mx - 2, my - 2, mw + 4, mh + 4);
  ctx.fillStyle = '#333';
  ctx.fillRect(mx, my, mw, mh);
  // Road
  ctx.fillStyle = '#555';
  ctx.fillRect(mx + 8, my, mw - 16, mh);
  // Player dot
  const px = mx + 8 + ((player.x - roadLeft) / (roadRight - roadLeft)) * (mw - 16);
  const py = my + mh - 10;
  ctx.fillStyle = '#33ff33';
  ctx.fillRect(px - 2, py - 3, 4, 6);
  // Enemy dots
  enemies.forEach(e => {
    const ex = mx + 8 + ((e.x - roadLeft) / (roadRight - roadLeft)) * (mw - 16);
    const ey = my + (e.y / H) * mh;
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(ex - 1, ey - 2, 3, 4);
  });
}

function drawCombo() {
  if (combo <= 1) return;
  ctx.font = 'bold 14px Courier New';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#ffcc00';
  ctx.fillText(`COMBO x${combo}`, 15, H - 20);
  // Combo bar
  const barW = 80;
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.fillRect(15, H - 15, barW, 6);
  ctx.fillStyle = '#ffcc00';
  ctx.fillRect(15, H - 15, barW * (comboTimer / 180), 6);
}

function resetGame() {
  score = 0;
  lives = 3;
  speed = 0;
  enemies = [];
  fuels = [];
  particles = [];
  sparks = [];
  textPopups = [];
  player.x = roadCenter;
  player.vx = 0;
  player.tilt = 0;
  difficulty = 1;
  shakeTimer = 0;
  flashTimer = 0;
  invincibleTimer = 0;
  combo = 0;
  comboTimer = 0;
  nightMode = false;
  nightTimer = 0;
  frameCount = 0;
}

function hitEnemy() {
  lives--;
  shakeTimer = 15;
  flashTimer = 10;
  invincibleTimer = 90;
  combo = 0;
  comboTimer = 0;
  speed = Math.max(speed - 4, 0);
  addParticle(player.x, player.y, '#ff4444', 15);
  addSpark(player.x, player.y);

  if (lives <= 0) {
    state = 'gameover';
    showOverlay('GAME OVER', score);
  }
}

function showOverlay(title, finalScore) {
  overlay.classList.remove('hidden');
  overlay.innerHTML = `
    <h1>${title}</h1>
    ${finalScore !== undefined ? `<div class="score-display">SCORE: ${finalScore}</div>` : '<h2>TURBO EDITION</h2>'}
    <div class="info">Arrow Keys / WASD to steer</div>
    <div class="info">Hold UP to accelerate</div>
    <div class="info">Avoid traffic & collect fuel</div>
    <button class="start-btn" id="startBtn">${finalScore !== undefined ? 'RETRY' : 'START'}</button>
  `;
  document.getElementById('startBtn').addEventListener('click', () => {
    resetGame();
    state = 'playing';
    overlay.classList.add('hidden');
  });
}

function update() {
  if (state !== 'playing') return;

  frameCount++;
  difficulty = 1 + Math.floor(score / 500) * 0.3;
  if (difficulty > 4) difficulty = 4;

  // Night cycle
  nightTimer++;
  if (nightTimer > 1800) {
    nightMode = !nightMode;
    nightTimer = 0;
  }

  // Input
  const left = keys['ArrowLeft'] || keys['a'] || keys['A'];
  const right = keys['ArrowRight'] || keys['d'] || keys['D'];
  const up = keys['ArrowUp'] || keys['w'] || keys['W'];
  const down = keys['ArrowDown'] || keys['s'] || keys['S'];

  // Acceleration
  if (up) {
    speed = Math.min(speed + 0.15, maxSpeed);
  } else if (down) {
    speed = Math.max(speed - 0.2, 0);
  } else {
    speed = Math.max(speed - 0.05, 0);
  }

  // Steering
  const steerSpeed = 4.5;
  if (left) {
    player.vx = Math.max(player.vx - 0.6, -steerSpeed);
    player.tilt = Math.max(player.tilt - 0.5, -3);
  } else if (right) {
    player.vx = Math.min(player.vx + 0.6, steerSpeed);
    player.tilt = Math.min(player.tilt + 0.5, 3);
  } else {
    player.vx *= 0.85;
    player.tilt *= 0.85;
  }

  player.x += player.vx;

  // Clamp to road
  if (player.x < roadLeft + player.w/2 + 5) {
    player.x = roadLeft + player.w/2 + 5;
    player.vx = 0;
    speed = Math.max(speed - 0.3, 0);
    if (frameCount % 5 === 0) addSpark(player.x - player.w/2, player.y + Math.random() * player.h - player.h/2);
  }
  if (player.x > roadRight - player.w/2 - 5) {
    player.x = roadRight - player.w/2 - 5;
    player.vx = 0;
    speed = Math.max(speed - 0.3, 0);
    if (frameCount % 5 === 0) addSpark(player.x + player.w/2, player.y + Math.random() * player.h - player.h/2);
  }

  // Road scroll
  roadOffset += speed;

  // Score
  if (speed > 0) {
    score += Math.floor(speed * 0.5);
  }

  // Combo timer
  if (comboTimer > 0) {
    comboTimer--;
    if (comboTimer <= 0) combo = 0;
  }

  // Spawn enemies
  const spawnRate = Math.max(40 - difficulty * 5, 12);
  if (frameCount % Math.floor(spawnRate) === 0) {
    spawnEnemy();
    // Sometimes spawn 2
    if (difficulty > 2 && Math.random() < 0.3) {
      setTimeout(() => spawnEnemy(), 100);
    }
  }

  // Spawn fuel
  if (frameCount % 180 === 0 && Math.random() < 0.6) {
    spawnFuel();
  }

  // Update enemies
  enemies.forEach(e => {
    e.y += e.speed + speed * 0.7;
  });
  enemies = enemies.filter(e => e.y < H + 100);

  // Update fuels
  fuels.forEach(f => {
    f.y += speed * 0.7;
    f.bobble += 0.1;
  });
  fuels = fuels.filter(f => f.y < H + 50);

  // Update scenery
  scenery.forEach(s => {
    s.y += speed * 0.4;
    if (s.y > H + 30) {
      s.y = -30;
      s.x = Math.random() < 0.5 ? Math.random() * 70 : roadRight + 20 + Math.random() * 70;
      s.type = Math.floor(Math.random() * 3);
    }
  });

  // Collision detection
  if (invincibleTimer <= 0) {
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      if (Math.abs(player.x - e.x) < (player.w + e.w) / 2 - 4 &&
          Math.abs(player.y - e.y) < (player.h + e.h) / 2 - 4) {
        enemies.splice(i, 1);
        hitEnemy();
        break;
      }
    }
  }

  // Fuel collision
  for (let i = fuels.length - 1; i >= 0; i--) {
    const f = fuels[i];
    if (Math.abs(player.x - f.x) < (player.w + f.w) / 2 &&
        Math.abs(player.y - f.y) < (player.h + f.h) / 2) {
      fuels.splice(i, 1);
      combo++;
      comboTimer = 180;
      const bonus = 100 * combo;
      score += bonus;
      addParticle(f.x, f.y, '#33ff33', 10);
      addTextPopup(f.x, f.y, `+${bonus}`, '#33ff33');
    }
  }

  // Passed car bonus
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (!e.passed && e.y > player.y + player.h) {
      e.passed = true;
      score += 10;
    }
  }

  // Update particles
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.96;
    p.vy *= 0.96;
    p.life--;
    p.size *= 0.97;
  });
  particles = particles.filter(p => p.life > 0);

  // Update sparks
  sparks.forEach(s => {
    s.x += s.vx;
    s.y += s.vy;
    s.life--;
  });
  sparks = sparks.filter(s => s.life > 0);

  // Update text popups
  textPopups.forEach(t => t.life--);
  textPopups = textPopups.filter(t => t.life > 0);

  // Timers
  if (shakeTimer > 0) shakeTimer--;
  if (flashTimer > 0) flashTimer--;
  if (invincibleTimer > 0) invincibleTimer--;

  // HUD
  scoreVal.textContent = score;
  speedVal.textContent = Math.floor(speed * 20);
  livesVal.textContent = lives;
}

function draw() {
  ctx.save();

  // Screen shake
  if (shakeTimer > 0) {
    const intensity = shakeTimer * 0.5;
    ctx.translate(
      (Math.random() - 0.5) * intensity * 2,
      (Math.random() - 0.5) * intensity * 2
    );
  }

  // Clear
  ctx.fillStyle = '#000';
  ctx.fillRect(-10, -10, W + 20, H + 20);

  // Draw road
  drawRoad();

  // Draw scenery
  scenery.forEach(s => drawSceneryItem(s));

  // Speed lines
  drawSpeedLines();

  // Draw fuels
  fuels.forEach(f => drawFuel(f));

  // Draw enemies
  enemies.forEach(e => {
    drawCar(e.x, e.y, e.w, e.h, e.colors, e.isTruck, false);
  });

  // Draw player (blink when invincible)
  if (invincibleTimer <= 0 || Math.floor(invincibleTimer / 4) % 2 === 0) {
    drawCar(player.x, player.y, player.w, player.h, ['#33ff33', '#22cc22', '#118811'], false, true);
  }

  // Particles & effects
  drawParticles();
  drawTextPopups();

  // Night overlay
  drawNightOverlay();

  // Flash on hit
  if (flashTimer > 0) {
    ctx.fillStyle = `rgba(255,0,0,${flashTimer * 0.05})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Minimap
  drawMinimap();

  // Combo display
  drawCombo();

  // CRT scanline effect
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let sy = 0; sy < H; sy += 3) {
    ctx.fillRect(0, sy, W, 1);
  }

  // Vignette
  const vig = ctx.createRadialGradient(W/2, H/2, W * 0.3, W/2, H/2, W * 0.75);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.4)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);

  ctx.restore();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Responsive canvas scaling
function resizeCanvas() {
  const scale = Math.min(window.innerWidth / W, window.innerHeight / H);
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Start
startBtn.addEventListener('click', () => {
  resetGame();
  state = 'playing';
  overlay.classList.add('hidden');
});

gameLoop();
</script>
</body>
</html>
