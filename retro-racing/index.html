<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>SPACE RACING - Void Runner</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Courier New', monospace;
    overflow: hidden;
  }
  @supports (height: 100dvh) {
    body { height: 100dvh; }
  }
  #gameContainer {
    position: relative;
    border: 2px solid #0088ff;
    box-shadow: 0 0 40px rgba(0,136,255,0.4), inset 0 0 40px rgba(0,136,255,0.05);
    image-rendering: pixelated;
  }
  canvas { display: block; }
  .home-btn {
    position: fixed; top: 10px; left: 10px; z-index: 999;
    width: 36px; height: 36px; border-radius: 6px;
    background: rgba(0,0,0,0.7); border: 2px solid #0088ff;
    color: #00ccff; font-size: 18px; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    text-decoration: none; text-shadow: 0 0 8px #0088ff;
    box-shadow: 0 0 10px rgba(0,136,255,0.3);
    transition: background 0.2s, box-shadow 0.2s;
  }
  .home-btn:hover { background: rgba(0,136,255,0.2); box-shadow: 0 0 20px rgba(0,136,255,0.5); }
  #overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.9);
    z-index: 10;
    transition: opacity 0.5s;
  }
  #overlay.hidden { opacity: 0; pointer-events: none; }
  #overlay h1 {
    font-size: 42px; color: #00ccff; text-shadow: 0 0 20px #0088ff, 0 0 40px #0044aa;
    letter-spacing: 8px; margin-bottom: 5px;
    animation: glow 2s ease-in-out infinite;
  }
  #overlay h2 {
    font-size: 16px; color: #ff6600; margin-bottom: 25px; letter-spacing: 4px;
    text-shadow: 0 0 10px #ff4400;
  }
  #overlay .info {
    font-size: 13px; color: #66aaff; margin: 4px 0; letter-spacing: 1px;
  }
  #overlay .start-btn {
    margin-top: 25px; padding: 14px 45px; font-size: 18px;
    font-family: 'Courier New', monospace; font-weight: bold;
    background: transparent; color: #00ccff;
    border: 2px solid #00ccff; cursor: pointer;
    letter-spacing: 4px; text-transform: uppercase;
    transition: all 0.3s;
    text-shadow: 0 0 10px #0088ff;
  }
  #overlay .start-btn:hover {
    background: rgba(0,136,255,0.2); color: #fff;
    box-shadow: 0 0 30px rgba(0,136,255,0.6), inset 0 0 20px rgba(0,136,255,0.2);
    border-color: #fff;
  }
  #overlay .score-display {
    font-size: 26px; color: #00ff88; margin: 12px 0;
    text-shadow: 0 0 15px #00ff88;
  }
  #overlay .highscore {
    font-size: 14px; color: #ffcc00; margin: 5px 0;
    text-shadow: 0 0 8px #ff8800;
  }
  #hud {
    position: absolute; top: 8px; left: 0; width: 100%;
    display: flex; justify-content: space-between; padding: 0 12px;
    z-index: 5; pointer-events: none;
  }
  #hud span {
    font-size: 13px; color: #fff; text-shadow: 0 0 5px rgba(0,136,255,0.5);
    letter-spacing: 2px;
  }
  #hud .speed { color: #ffcc00; }
  #hud .score { color: #00ff88; }
  #hud .shield { color: #00ccff; }
  @keyframes glow {
    0%, 100% { text-shadow: 0 0 20px #0088ff, 0 0 40px #0044aa; }
    50% { text-shadow: 0 0 30px #00ccff, 0 0 60px #0088ff, 0 0 80px #0044aa; }
  }
  #boostBar {
    position: absolute; bottom: 8px; left: 50%; transform: translateX(-50%);
    z-index: 5; pointer-events: none; text-align: center;
  }
  #boostBar .label {
    font-size: 10px; color: #ff6600; letter-spacing: 2px;
    text-shadow: 0 0 5px #ff4400;
  }
  #boostBarInner {
    width: 150px; height: 6px; background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,102,0,0.3); margin-top: 2px;
    border-radius: 3px; overflow: hidden;
  }
  #boostBarFill {
    width: 100%; height: 100%;
    background: linear-gradient(90deg, #ff4400, #ff8800, #ffcc00);
    border-radius: 3px;
    transition: width 0.1s;
    box-shadow: 0 0 8px rgba(255,102,0,0.5);
  }
  #joystick {
    display: none;
    touch-action: none;
  }
  @media (pointer: coarse) {
    body {
      flex-direction: column;
      padding: env(safe-area-inset-top, 0px) 0 env(safe-area-inset-bottom, 0px);
    }
    #gameContainer {
      flex-shrink: 1; min-height: 0;
      max-height: calc(100dvh - 140px - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
    }
    canvas {
      max-height: calc(100dvh - 140px - env(safe-area-inset-top, 0px) - env(safe-area-inset-bottom, 0px));
      width: auto;
    }
    #touchControls {
      display: flex; width: 100%; height: 130px; flex-shrink: 0;
      justify-content: flex-end; align-items: center;
      padding: 0 20px; pointer-events: none;
    }
    #joystick { display: block; pointer-events: auto; }
  }
  #joystickBase {
    width: 120px; height: 120px; border-radius: 50%;
    background: rgba(0,136,255,0.06);
    border: 2px solid rgba(0,136,255,0.2);
    box-shadow: 0 0 15px rgba(0,136,255,0.05), inset 0 0 15px rgba(0,136,255,0.03);
    position: relative;
    display: flex; justify-content: center; align-items: center;
    cursor: pointer;
  }
  #joystickKnob {
    width: 48px; height: 48px; border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, rgba(0,136,255,0.4), rgba(0,136,255,0.15));
    border: 2px solid rgba(0,136,255,0.5);
    box-shadow: 0 0 10px rgba(0,136,255,0.3);
    position: absolute;
    pointer-events: none;
  }
  #joystickBase::after {
    content: '+'; position: absolute;
    color: rgba(0,136,255,0.12); font-size: 50px;
    font-family: 'Courier New', monospace; font-weight: 100;
    pointer-events: none;
  }
</style>
</head>
<body>
<a href="../" class="home-btn" title="Back to Arcade">&#8962;</a>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div id="hud">
    <span class="score">SCORE: <span id="scoreVal">0</span></span>
    <span class="speed">WARP: <span id="speedVal">0</span></span>
    <span class="shield">SHIELD: <span id="shieldVal">███</span></span>
  </div>
  <div id="boostBar">
    <div id="boostBarInner"><div id="boostBarFill"></div></div>
    <div class="label">BOOST [SPACE]</div>
  </div>
  <div id="overlay">
    <h1>VOID RUNNER</h1>
    <h2>⚡ SPACE RACING ⚡</h2>
    <div class="info">Arrow Keys / WASD / Joystick to pilot</div>
    <div class="info">SPACE / Double-tap for Boost</div>
    <div class="info">Dodge asteroids & collect energy</div>
    <button class="start-btn" id="startBtn">LAUNCH</button>
  </div>

</div>
<div id="touchControls">
  <div id="joystick">
    <div id="joystickBase">
      <div id="joystickKnob"></div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const W = 480, H = 720;
canvas.width = W;
canvas.height = H;

const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const scoreVal = document.getElementById('scoreVal');
const speedVal = document.getElementById('speedVal');
const shieldVal = document.getElementById('shieldVal');
const boostBarFill = document.getElementById('boostBarFill');

// Game state
let state = 'menu';
let score = 0;
let highScore = parseInt(localStorage.getItem('voidRunnerHigh') || '0');
let shield = 3;
let speed = 0;
let maxSpeed = 14;
let frameCount = 0;
let difficulty = 1;
let shakeTimer = 0;
let flashTimer = 0;
let flashColor = '#ff0000';
let invincibleTimer = 0;
let combo = 0;
let comboTimer = 0;
let particles = [];
let textPopups = [];
let boostFuel = 100;
let boosting = false;
let boostCooldown = 0;
let warpIntensity = 0;
let distanceTraveled = 0;

// Stars layers (parallax)
const starLayers = [[], [], []];
const starSpeeds = [0.5, 1.2, 2.5];
const starSizes = [1, 1.5, 2];
for (let layer = 0; layer < 3; layer++) {
  const count = [80, 50, 25][layer];
  for (let i = 0; i < count; i++) {
    starLayers[layer].push({
      x: Math.random() * W,
      y: Math.random() * H,
      brightness: 0.3 + Math.random() * 0.7,
      twinkle: Math.random() * Math.PI * 2
    });
  }
}

// Nebula clouds
let nebulae = [];
for (let i = 0; i < 5; i++) {
  nebulae.push({
    x: Math.random() * W,
    y: Math.random() * H,
    r: 60 + Math.random() * 100,
    hue: Math.random() * 360,
    alpha: 0.03 + Math.random() * 0.04
  });
}

// Track lanes
const trackLeft = 60;
const trackRight = 420;
const trackCenter = (trackLeft + trackRight) / 2;
const laneCount = 5;
const laneWidth = (trackRight - trackLeft) / laneCount;
const lanes = [];
for (let i = 0; i < laneCount; i++) {
  lanes.push(trackLeft + laneWidth * (i + 0.5));
}

// Player ship
const player = {
  x: trackCenter,
  y: H - 130,
  w: 32,
  h: 48,
  vx: 0,
  tilt: 0,
  engineGlow: 0,
  trailParticles: []
};

// Input
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (e.key === ' ') e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.key] = false; });

// Joystick
const joystickBase = document.getElementById('joystickBase');
const joystickKnob = document.getElementById('joystickKnob');
let joystickX = 0, joystickY = 0, joystickActive = false;
const jBaseR = 60, jKnobR = 24, jMaxDist = jBaseR - jKnobR;

function updateKnobPos() {
  joystickKnob.style.transform = `translate(${joystickX * jMaxDist}px, ${joystickY * jMaxDist}px)`;
}
function handleJoystick(cx, cy) {
  const rect = joystickBase.getBoundingClientRect();
  let dx = cx - (rect.left + rect.width / 2);
  let dy = cy - (rect.top + rect.height / 2);
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist > jMaxDist) { dx = dx / dist * jMaxDist; dy = dy / dist * jMaxDist; }
  joystickX = dx / jMaxDist;
  joystickY = dy / jMaxDist;
  updateKnobPos();
}
function resetJoystick() {
  joystickX = 0; joystickY = 0; joystickActive = false;
  updateKnobPos();
}

// Touch double-tap for boost
let lastTapTime = 0;
joystickBase.addEventListener('touchstart', e => {
  e.preventDefault();
  joystickActive = true;
  handleJoystick(e.touches[0].clientX, e.touches[0].clientY);
  const now = Date.now();
  if (now - lastTapTime < 300) { activateBoost(); }
  lastTapTime = now;
});
document.addEventListener('touchmove', e => {
  if (joystickActive) { e.preventDefault(); handleJoystick(e.touches[0].clientX, e.touches[0].clientY); }
}, { passive: false });
document.addEventListener('touchend', () => { if (joystickActive) resetJoystick(); });

joystickBase.addEventListener('mousedown', e => {
  e.preventDefault(); joystickActive = true; handleJoystick(e.clientX, e.clientY);
});
document.addEventListener('mousemove', e => { if (joystickActive) handleJoystick(e.clientX, e.clientY); });
document.addEventListener('mouseup', () => { if (joystickActive) resetJoystick(); });

// Obstacles
let obstacles = [];
const asteroidShapes = [];
// Pre-generate asteroid shapes
for (let s = 0; s < 8; s++) {
  const pts = [];
  const numPts = 7 + Math.floor(Math.random() * 5);
  for (let i = 0; i < numPts; i++) {
    const angle = (Math.PI * 2 / numPts) * i;
    const r = 0.6 + Math.random() * 0.4;
    pts.push({ angle, r });
  }
  asteroidShapes.push(pts);
}

// Energy orbs
let energyOrbs = [];

// Enemy ships (rival racers)
let rivalShips = [];

// Space debris / floating objects
let spaceDebris = [];
for (let i = 0; i < 12; i++) {
  spaceDebris.push({
    x: Math.random() * W,
    y: Math.random() * H,
    size: 2 + Math.random() * 5,
    rot: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.05,
    type: Math.floor(Math.random() * 3),
    color: ['#334', '#445', '#223'][Math.floor(Math.random() * 3)]
  });
}

function spawnAsteroid() {
  const size = 18 + Math.random() * 30;
  const x = trackLeft + Math.random() * (trackRight - trackLeft);
  obstacles.push({
    x, y: -size - 20,
    size,
    shape: asteroidShapes[Math.floor(Math.random() * asteroidShapes.length)],
    rot: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random() - 0.5) * 0.04,
    speed: 1 + Math.random() * 2,
    color: Math.random() < 0.3 ? '#886644' : (Math.random() < 0.5 ? '#667' : '#556')
  });
}

function spawnRival() {
  const lane = Math.floor(Math.random() * laneCount);
  const colors = [
    { main: '#ff3344', accent: '#ff6677', engine: '#ff8800' },
    { main: '#8833ff', accent: '#aa66ff', engine: '#cc44ff' },
    { main: '#ff8800', accent: '#ffaa33', engine: '#ffcc00' },
    { main: '#33ff88', accent: '#66ffaa', engine: '#88ffcc' }
  ];
  const c = colors[Math.floor(Math.random() * colors.length)];
  rivalShips.push({
    x: lanes[lane],
    y: -60,
    w: 28, h: 44,
    speed: 1.5 + Math.random() * 2.5,
    colors: c,
    lane,
    sway: Math.random() * Math.PI * 2,
    swayAmt: Math.random() * 15
  });
}

function spawnEnergy() {
  const lane = Math.floor(Math.random() * laneCount);
  const type = Math.random() < 0.2 ? 'shield' : (Math.random() < 0.3 ? 'boost' : 'energy');
  energyOrbs.push({
    x: lanes[lane],
    y: -25,
    type,
    pulse: Math.random() * Math.PI * 2,
    size: type === 'shield' ? 14 : (type === 'boost' ? 12 : 10)
  });
}

function addParticle(x, y, color, count, opts = {}) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (opts.vx || 0) + (Math.random() - 0.5) * (opts.spread || 8),
      vy: (opts.vy || 0) + (Math.random() - 0.5) * (opts.spread || 8),
      life: (opts.life || 30) + Math.random() * 20,
      maxLife: (opts.life || 30) + 20,
      color,
      size: (opts.size || 2) + Math.random() * (opts.sizeVar || 3),
      glow: opts.glow || false
    });
  }
}

function addTextPopup(x, y, text, color) {
  textPopups.push({ x, y, text, color, life: 50, maxLife: 50 });
}

function activateBoost() {
  if (boostFuel >= 30 && boostCooldown <= 0 && state === 'playing') {
    boosting = true;
    boostCooldown = 10;
  }
}

// Draw spaceship
function drawShip(x, y, w, h, colors, isPlayer, tilt) {
  ctx.save();
  ctx.translate(x, y);
  if (tilt) ctx.rotate(tilt * 0.05);

  const hw = w / 2, hh = h / 2;

  // Engine glow
  if (isPlayer) {
    const glowSize = 10 + player.engineGlow * 15 + Math.sin(frameCount * 0.3) * 3;
    const grad = ctx.createRadialGradient(0, hh + 5, 2, 0, hh + 5, glowSize);
    grad.addColorStop(0, boosting ? 'rgba(255,136,0,0.9)' : 'rgba(0,136,255,0.8)');
    grad.addColorStop(0.4, boosting ? 'rgba(255,68,0,0.4)' : 'rgba(0,100,255,0.3)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, hh + 5, glowSize, 0, Math.PI * 2);
    ctx.fill();

    // Engine flame
    const flameH = 8 + speed * 2.5 + (boosting ? 20 : 0) + Math.sin(frameCount * 0.5) * 3;
    const flameGrad = ctx.createLinearGradient(0, hh, 0, hh + flameH);
    if (boosting) {
      flameGrad.addColorStop(0, '#ffffff');
      flameGrad.addColorStop(0.2, '#ffcc00');
      flameGrad.addColorStop(0.5, '#ff6600');
      flameGrad.addColorStop(1, 'rgba(255,0,0,0)');
    } else {
      flameGrad.addColorStop(0, '#aaddff');
      flameGrad.addColorStop(0.3, '#0088ff');
      flameGrad.addColorStop(0.6, '#0044aa');
      flameGrad.addColorStop(1, 'rgba(0,0,80,0)');
    }
    ctx.fillStyle = flameGrad;
    ctx.beginPath();
    ctx.moveTo(-8, hh);
    ctx.quadraticCurveTo(-4 + Math.sin(frameCount * 0.8) * 3, hh + flameH * 0.6, 0, hh + flameH);
    ctx.quadraticCurveTo(4 + Math.sin(frameCount * 0.7) * 3, hh + flameH * 0.6, 8, hh);
    ctx.fill();

    // Side thrusters
    ctx.fillStyle = flameGrad;
    ctx.beginPath();
    ctx.moveTo(-hw - 2, hh - 5);
    ctx.lineTo(-hw - 2, hh + 4 + speed);
    ctx.lineTo(-hw + 3, hh - 5);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(hw + 2, hh - 5);
    ctx.lineTo(hw + 2, hh + 4 + speed);
    ctx.lineTo(hw - 3, hh - 5);
    ctx.fill();
  } else {
    // Rival engine glow
    const eg = 8 + Math.sin(frameCount * 0.4) * 2;
    const grad = ctx.createRadialGradient(0, hh + 3, 1, 0, hh + 3, eg);
    grad.addColorStop(0, colors.engine);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, hh + 3, eg, 0, Math.PI * 2);
    ctx.fill();
  }

  // Ship body shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.moveTo(0, -hh + 3);
  ctx.lineTo(-hw + 1, hh + 3);
  ctx.lineTo(hw + 1, hh + 3);
  ctx.closePath();
  ctx.fill();

  // Ship body
  const bodyColor = isPlayer ? '#0088ff' : colors.main;
  const accentColor = isPlayer ? '#00aaff' : colors.accent;

  // Main hull
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.moveTo(0, -hh);
  ctx.lineTo(-hw + 4, -hh * 0.2);
  ctx.lineTo(-hw, hh - 5);
  ctx.lineTo(-hw + 6, hh);
  ctx.lineTo(hw - 6, hh);
  ctx.lineTo(hw, hh - 5);
  ctx.lineTo(hw - 4, -hh * 0.2);
  ctx.closePath();
  ctx.fill();

  // Hull highlight
  ctx.fillStyle = accentColor;
  ctx.beginPath();
  ctx.moveTo(0, -hh);
  ctx.lineTo(-hw + 8, -hh * 0.1);
  ctx.lineTo(-hw + 6, hh * 0.3);
  ctx.lineTo(0, hh * 0.1);
  ctx.closePath();
  ctx.fill();

  // Cockpit
  if (isPlayer) {
    const cockpitGrad = ctx.createLinearGradient(0, -hh + 8, 0, -hh + 22);
    cockpitGrad.addColorStop(0, '#66ddff');
    cockpitGrad.addColorStop(1, '#0066aa');
    ctx.fillStyle = cockpitGrad;
  } else {
    ctx.fillStyle = '#223';
  }
  ctx.beginPath();
  ctx.ellipse(0, -hh * 0.35, hw * 0.35, hh * 0.25, 0, 0, Math.PI * 2);
  ctx.fill();

  // Wings
  ctx.fillStyle = isPlayer ? '#0066cc' : colors.main;
  // Left wing
  ctx.beginPath();
  ctx.moveTo(-hw + 4, -hh * 0.15);
  ctx.lineTo(-hw - 6, hh * 0.3);
  ctx.lineTo(-hw, hh - 3);
  ctx.lineTo(-hw + 4, hh * 0.2);
  ctx.closePath();
  ctx.fill();
  // Right wing
  ctx.beginPath();
  ctx.moveTo(hw - 4, -hh * 0.15);
  ctx.lineTo(hw + 6, hh * 0.3);
  ctx.lineTo(hw, hh - 3);
  ctx.lineTo(hw - 4, hh * 0.2);
  ctx.closePath();
  ctx.fill();

  // Wing tips glow
  if (isPlayer) {
    const wingGlow = Math.sin(frameCount * 0.15) * 0.3 + 0.7;
    ctx.fillStyle = `rgba(0,200,255,${wingGlow * 0.6})`;
    ctx.beginPath();
    ctx.arc(-hw - 4, hh * 0.35, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(hw + 4, hh * 0.35, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // Shield effect when invincible
  if (isPlayer && invincibleTimer > 0) {
    const shieldAlpha = 0.15 + Math.sin(frameCount * 0.3) * 0.1;
    ctx.strokeStyle = `rgba(0,200,255,${shieldAlpha + 0.3})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(0, 0, hw + 8, hh + 8, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = `rgba(0,150,255,${shieldAlpha})`;
    ctx.fill();
  }

  ctx.restore();

  // Engine trail particles
  if (isPlayer && state === 'playing' && speed > 1) {
    if (frameCount % 2 === 0) {
      const trailColor = boosting ? '#ff6600' : '#0066ff';
      addParticle(x - 5, y + player.h / 2 + 5, trailColor, 1, { vy: 2, spread: 2, size: 2, life: 15 });
      addParticle(x + 5, y + player.h / 2 + 5, trailColor, 1, { vy: 2, spread: 2, size: 2, life: 15 });
    }
  }
}

function drawAsteroid(o) {
  ctx.save();
  ctx.translate(o.x, o.y);
  ctx.rotate(o.rot);

  const pts = o.shape;
  const s = o.size;

  // Glow
  ctx.fillStyle = `rgba(100,80,60,0.08)`;
  ctx.beginPath();
  ctx.arc(0, 0, s + 8, 0, Math.PI * 2);
  ctx.fill();

  // Main body
  ctx.fillStyle = o.color;
  ctx.beginPath();
  ctx.moveTo(Math.cos(pts[0].angle) * s * pts[0].r, Math.sin(pts[0].angle) * s * pts[0].r);
  for (let i = 1; i < pts.length; i++) {
    ctx.lineTo(Math.cos(pts[i].angle) * s * pts[i].r, Math.sin(pts[i].angle) * s * pts[i].r);
  }
  ctx.closePath();
  ctx.fill();

  // Lighter face
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(Math.cos(pts[0].angle) * s * pts[0].r, Math.sin(pts[0].angle) * s * pts[0].r);
  ctx.lineTo(Math.cos(pts[1].angle) * s * pts[1].r, Math.sin(pts[1].angle) * s * pts[1].r);
  ctx.closePath();
  ctx.fill();

  // Craters
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.arc(s * 0.2, -s * 0.15, s * 0.18, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(-s * 0.25, s * 0.2, s * 0.12, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawEnergyOrb(orb) {
  const pulse = Math.sin(orb.pulse) * 0.3 + 1;
  const s = orb.size * pulse;
  const x = orb.x, y = orb.y;

  if (orb.type === 'energy') {
    // Green energy orb
    const grad = ctx.createRadialGradient(x, y, 0, x, y, s + 6);
    grad.addColorStop(0, 'rgba(0,255,136,0.9)');
    grad.addColorStop(0.5, 'rgba(0,200,100,0.4)');
    grad.addColorStop(1, 'rgba(0,100,50,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, s + 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#00ff88';
    ctx.beginPath();
    ctx.arc(x, y, s * 0.6, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(x - 2, y - 2, s * 0.2, 0, Math.PI * 2);
    ctx.fill();
  } else if (orb.type === 'shield') {
    // Blue shield orb
    const grad = ctx.createRadialGradient(x, y, 0, x, y, s + 8);
    grad.addColorStop(0, 'rgba(0,180,255,0.9)');
    grad.addColorStop(0.5, 'rgba(0,100,200,0.4)');
    grad.addColorStop(1, 'rgba(0,50,100,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, s + 8, 0, Math.PI * 2);
    ctx.fill();

    // Shield icon
    ctx.strokeStyle = '#00ccff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, s * 0.5, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(0,200,255,0.5)';
    ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(s * 0.7)}px Courier New`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('S', x, y + 1);
  } else {
    // Orange boost orb
    const grad = ctx.createRadialGradient(x, y, 0, x, y, s + 7);
    grad.addColorStop(0, 'rgba(255,136,0,0.9)');
    grad.addColorStop(0.5, 'rgba(200,80,0,0.4)');
    grad.addColorStop(1, 'rgba(100,40,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, s + 7, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#ff8800';
    ctx.beginPath();
    // Lightning bolt shape
    ctx.moveTo(x + 2, y - s * 0.8);
    ctx.lineTo(x - 4, y + 1);
    ctx.lineTo(x + 1, y + 1);
    ctx.lineTo(x - 2, y + s * 0.8);
    ctx.lineTo(x + 5, y - 1);
    ctx.lineTo(x, y - 1);
    ctx.closePath();
    ctx.fill();
  }
}

function drawStarfield() {
  for (let layer = 0; layer < 3; layer++) {
    starLayers[layer].forEach(star => {
      const twinkle = Math.sin(star.twinkle + frameCount * 0.02 * (layer + 1)) * 0.3 + 0.7;
      const alpha = star.brightness * twinkle;
      const size = starSizes[layer];

      if (layer === 2 && star.brightness > 0.8) {
        // Bright star glow
        ctx.fillStyle = `rgba(100,150,255,${alpha * 0.15})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, size + 3, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = `rgba(200,220,255,${alpha})`;
      ctx.fillRect(star.x - size / 2, star.y - size / 2, size, size);
    });
  }
}

function drawNebulae() {
  nebulae.forEach(n => {
    const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
    const hue = n.hue;
    grad.addColorStop(0, `hsla(${hue}, 80%, 50%, ${n.alpha})`);
    grad.addColorStop(0.5, `hsla(${hue + 20}, 60%, 30%, ${n.alpha * 0.5})`);
    grad.addColorStop(1, `hsla(${hue}, 40%, 20%, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawTrack() {
  // Track border glow
  const borderGlow = Math.sin(frameCount * 0.05) * 0.1 + 0.2;

  // Track background
  ctx.fillStyle = 'rgba(10,15,30,0.6)';
  ctx.fillRect(trackLeft, 0, trackRight - trackLeft, H);

  // Grid lines (scrolling)
  const gridSpacing = 50;
  ctx.strokeStyle = 'rgba(0,80,180,0.08)';
  ctx.lineWidth = 1;
  for (let gy = (distanceTraveled * 0.8) % gridSpacing - gridSpacing; gy < H; gy += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(trackLeft, gy);
    ctx.lineTo(trackRight, gy);
    ctx.stroke();
  }
  for (let gx = trackLeft; gx <= trackRight; gx += laneWidth) {
    ctx.beginPath();
    ctx.moveTo(gx, 0);
    ctx.lineTo(gx, H);
    ctx.stroke();
  }

  // Lane markers (dashed, neon)
  const dashLen = 30, gapLen = 25;
  for (let i = 1; i < laneCount; i++) {
    const lx = trackLeft + laneWidth * i;
    ctx.fillStyle = `rgba(0,100,200,${0.12 + borderGlow * 0.1})`;
    for (let dy = (distanceTraveled % (dashLen + gapLen)) - dashLen; dy < H; dy += dashLen + gapLen) {
      ctx.fillRect(lx - 1, dy, 2, dashLen);
    }
  }

  // Track borders (energy walls)
  const segments = 20;
  const segH = H / segments;
  for (let i = 0; i < segments; i++) {
    const oy = i * segH;
    const pulse = Math.sin(frameCount * 0.08 + i * 0.5) * 0.15 + 0.35;

    // Left border
    ctx.fillStyle = `rgba(0,136,255,${pulse})`;
    ctx.fillRect(trackLeft - 3, oy, 3, segH);
    // Left glow
    const lgGrad = ctx.createLinearGradient(trackLeft - 15, 0, trackLeft, 0);
    lgGrad.addColorStop(0, 'rgba(0,136,255,0)');
    lgGrad.addColorStop(1, `rgba(0,136,255,${pulse * 0.3})`);
    ctx.fillStyle = lgGrad;
    ctx.fillRect(trackLeft - 15, oy, 15, segH);

    // Right border
    ctx.fillStyle = `rgba(0,136,255,${pulse})`;
    ctx.fillRect(trackRight, oy, 3, segH);
    // Right glow
    const rgGrad = ctx.createLinearGradient(trackRight, 0, trackRight + 15, 0);
    rgGrad.addColorStop(0, `rgba(0,136,255,${pulse * 0.3})`);
    rgGrad.addColorStop(1, 'rgba(0,136,255,0)');
    ctx.fillStyle = rgGrad;
    ctx.fillRect(trackRight, oy, 15, segH);
  }
}

function drawWarpLines() {
  if (warpIntensity < 0.05) return;
  const count = Math.floor(warpIntensity * 20);
  ctx.globalAlpha = warpIntensity * 0.6;
  for (let i = 0; i < count; i++) {
    const sx = trackLeft + Math.random() * (trackRight - trackLeft);
    const sy = Math.random() * H;
    const len = 20 + warpIntensity * 80;
    const grad = ctx.createLinearGradient(sx, sy, sx, sy + len);
    grad.addColorStop(0, boosting ? '#ff8800' : '#0088ff');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.strokeStyle = grad;
    ctx.lineWidth = 1 + Math.random();
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.lineTo(sx + (Math.random() - 0.5) * 2, sy + len);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawSpaceDebris() {
  spaceDebris.forEach(d => {
    ctx.save();
    ctx.translate(d.x, d.y);
    ctx.rotate(d.rot);
    ctx.fillStyle = d.color;
    if (d.type === 0) {
      ctx.fillRect(-d.size / 2, -d.size / 2, d.size, d.size * 0.6);
    } else if (d.type === 1) {
      ctx.beginPath();
      ctx.moveTo(0, -d.size / 2);
      ctx.lineTo(-d.size / 2, d.size / 2);
      ctx.lineTo(d.size / 2, d.size / 2);
      ctx.closePath();
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.arc(0, 0, d.size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  });
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    if (p.glow) {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size + 2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  });
  ctx.globalAlpha = 1;
}

function drawTextPopups() {
  textPopups.forEach(t => {
    const alpha = t.life / t.maxLife;
    const rise = (t.maxLife - t.life) * 0.8;
    ctx.globalAlpha = alpha;
    ctx.font = 'bold 16px Courier New';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillText(t.text, t.x + 1, t.y - rise + 1);
    ctx.fillStyle = t.color;
    ctx.fillText(t.text, t.x, t.y - rise);
    // Glow
    ctx.shadowColor = t.color;
    ctx.shadowBlur = 8;
    ctx.fillText(t.text, t.x, t.y - rise);
    ctx.shadowBlur = 0;
  });
  ctx.globalAlpha = 1;
}

function drawMinimap() {
  const mx = W - 50, my = 45, mw = 35, mh = 110;
  ctx.fillStyle = 'rgba(0,10,30,0.7)';
  ctx.fillRect(mx - 2, my - 2, mw + 4, mh + 4);
  ctx.strokeStyle = 'rgba(0,136,255,0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(mx - 2, my - 2, mw + 4, mh + 4);

  ctx.fillStyle = 'rgba(0,40,80,0.3)';
  ctx.fillRect(mx, my, mw, mh);

  // Player
  const px = mx + ((player.x - trackLeft) / (trackRight - trackLeft)) * mw;
  ctx.fillStyle = '#00ccff';
  ctx.fillRect(px - 2, my + mh - 12, 4, 6);

  // Obstacles
  obstacles.forEach(o => {
    const ex = mx + ((o.x - trackLeft) / (trackRight - trackLeft)) * mw;
    const ey = my + (o.y / H) * mh;
    ctx.fillStyle = '#886644';
    ctx.fillRect(ex - 1, ey - 1, 3, 3);
  });

  // Rivals
  rivalShips.forEach(r => {
    const ex = mx + ((r.x - trackLeft) / (trackRight - trackLeft)) * mw;
    const ey = my + (r.y / H) * mh;
    ctx.fillStyle = '#ff3344';
    ctx.fillRect(ex - 1, ey - 2, 3, 4);
  });

  // Orbs
  energyOrbs.forEach(e => {
    const ex = mx + ((e.x - trackLeft) / (trackRight - trackLeft)) * mw;
    const ey = my + (e.y / H) * mh;
    ctx.fillStyle = e.type === 'energy' ? '#00ff88' : (e.type === 'shield' ? '#00ccff' : '#ff8800');
    ctx.fillRect(ex - 1, ey - 1, 2, 2);
  });
}

function drawCombo() {
  if (combo <= 1) return;
  const alpha = comboTimer / 180;
  ctx.globalAlpha = alpha;
  ctx.font = 'bold 14px Courier New';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#ffcc00';
  ctx.shadowColor = '#ff8800';
  ctx.shadowBlur = 6;
  ctx.fillText(`COMBO x${combo}`, 15, H - 30);
  ctx.shadowBlur = 0;

  const barW = 80;
  ctx.fillStyle = 'rgba(255,255,255,0.1)';
  ctx.fillRect(15, H - 22, barW, 5);
  const comboGrad = ctx.createLinearGradient(15, 0, 15 + barW, 0);
  comboGrad.addColorStop(0, '#ff6600');
  comboGrad.addColorStop(1, '#ffcc00');
  ctx.fillStyle = comboGrad;
  ctx.fillRect(15, H - 22, barW * (comboTimer / 180), 5);
  ctx.globalAlpha = 1;
}

function drawDistanceCounter() {
  const km = (distanceTraveled / 100).toFixed(1);
  ctx.font = '11px Courier New';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(0,136,255,0.5)';
  ctx.fillText(`${km} LY`, W / 2, 30);
}

function resetGame() {
  score = 0;
  shield = 3;
  speed = 0;
  obstacles = [];
  rivalShips = [];
  energyOrbs = [];
  particles = [];
  textPopups = [];
  player.x = trackCenter;
  player.vx = 0;
  player.tilt = 0;
  player.engineGlow = 0;
  difficulty = 1;
  shakeTimer = 0;
  flashTimer = 0;
  invincibleTimer = 0;
  combo = 0;
  comboTimer = 0;
  boostFuel = 100;
  boosting = false;
  boostCooldown = 0;
  warpIntensity = 0;
  distanceTraveled = 0;
  frameCount = 0;
}

function hitObstacle() {
  shield--;
  shakeTimer = 15;
  flashTimer = 12;
  flashColor = '#ff0000';
  invincibleTimer = 90;
  combo = 0;
  comboTimer = 0;
  speed = Math.max(speed - 4, 0);
  addParticle(player.x, player.y, '#ff4444', 15, { spread: 10 });
  addParticle(player.x, player.y, '#ffaa00', 8, { spread: 6, glow: true });

  if (shield <= 0) {
    // Explosion
    addParticle(player.x, player.y, '#ff6600', 30, { spread: 15, life: 40 });
    addParticle(player.x, player.y, '#ffcc00', 20, { spread: 12, life: 35, glow: true });
    addParticle(player.x, player.y, '#ff0000', 15, { spread: 18, life: 45 });
    state = 'gameover';
    if (score > highScore) {
      highScore = score;
      localStorage.setItem('voidRunnerHigh', highScore.toString());
    }
    showOverlay('DESTROYED', score);
  }
}

function showOverlay(title, finalScore) {
  overlay.classList.remove('hidden');
  let html = `<h1>${title}</h1>`;
  if (finalScore !== undefined) {
    html += `<div class="score-display">SCORE: ${finalScore}</div>`;
    html += `<div class="highscore">BEST: ${highScore}</div>`;
    html += `<div class="info" style="margin-top:8px">DISTANCE: ${(distanceTraveled / 100).toFixed(1)} LIGHT YEARS</div>`;
  } else {
    html += '<h2>⚡ SPACE RACING ⚡</h2>';
  }
  html += `
    <div class="info" style="margin-top:15px">Arrow Keys / WASD / Joystick to pilot</div>
    <div class="info">SPACE / Double-tap for Boost</div>
    <div class="info">Dodge asteroids & collect energy</div>
    <button class="start-btn" id="startBtn">${finalScore !== undefined ? 'RELAUNCH' : 'LAUNCH'}</button>
  `;
  overlay.innerHTML = html;
  document.getElementById('startBtn').addEventListener('click', () => {
    resetGame();
    state = 'playing';
    overlay.classList.add('hidden');
  });
}

function update() {
  if (state !== 'playing') return;

  frameCount++;
  difficulty = 1 + Math.floor(score / 500) * 0.25;
  if (difficulty > 5) difficulty = 5;

  // Input
  const dz = 0.15;
  const jx = Math.abs(joystickX) > dz ? joystickX : 0;
  const jy = Math.abs(joystickY) > dz ? joystickY : 0;
  let inputX = jx, inputY = jy;
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) inputX = -1;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) inputX = 1;
  if (keys['ArrowUp'] || keys['w'] || keys['W']) inputY = -1;
  if (keys['ArrowDown'] || keys['s'] || keys['S']) inputY = 1;

  // Boost
  if (keys[' '] && boostFuel >= 30 && boostCooldown <= 0) {
    activateBoost();
  }

  if (boosting) {
    boostFuel -= 1.5;
    if (boostFuel <= 0) {
      boosting = false;
      boostFuel = 0;
    }
    speed = Math.min(speed + 0.3, maxSpeed * 1.5);
  } else {
    if (boostFuel < 100) boostFuel += 0.15;
  }
  if (boostCooldown > 0) boostCooldown--;

  // Acceleration
  const currentMax = boosting ? maxSpeed * 1.5 : maxSpeed;
  if (inputY < -dz) {
    speed = Math.min(speed + 0.18 * Math.abs(inputY), currentMax);
  } else if (inputY > dz) {
    speed = Math.max(speed - 0.25 * Math.abs(inputY), 0);
  } else if (!boosting) {
    speed = Math.max(speed - 0.04, 0);
  }

  // Engine glow based on speed
  player.engineGlow = speed / maxSpeed;

  // Warp intensity
  const targetWarp = speed > 8 ? (speed - 8) / (maxSpeed * 1.5 - 8) : 0;
  warpIntensity += (targetWarp - warpIntensity) * 0.1;

  // Steering
  const steerSpeed = 5;
  if (inputX < -dz) {
    const amt = Math.abs(inputX);
    player.vx = Math.max(player.vx - 0.7 * amt, -steerSpeed);
    player.tilt = Math.max(player.tilt - 0.6 * amt, -3);
  } else if (inputX > dz) {
    const amt = Math.abs(inputX);
    player.vx = Math.min(player.vx + 0.7 * amt, steerSpeed);
    player.tilt = Math.min(player.tilt + 0.6 * amt, 3);
  } else {
    player.vx *= 0.82;
    player.tilt *= 0.82;
  }

  player.x += player.vx;

  // Clamp to track
  if (player.x < trackLeft + player.w / 2 + 5) {
    player.x = trackLeft + player.w / 2 + 5;
    player.vx = Math.abs(player.vx) * 0.3;
    speed = Math.max(speed - 0.2, 0);
    flashTimer = 3;
    flashColor = '#0088ff';
    addParticle(trackLeft, player.y, '#0088ff', 3, { spread: 3, glow: true });
  }
  if (player.x > trackRight - player.w / 2 - 5) {
    player.x = trackRight - player.w / 2 - 5;
    player.vx = -Math.abs(player.vx) * 0.3;
    speed = Math.max(speed - 0.2, 0);
    flashTimer = 3;
    flashColor = '#0088ff';
    addParticle(trackRight, player.y, '#0088ff', 3, { spread: 3, glow: true });
  }

  // Distance
  distanceTraveled += speed;

  // Score
  if (speed > 0) {
    score += Math.floor(speed * 0.5);
  }

  // Combo timer
  if (comboTimer > 0) {
    comboTimer--;
    if (comboTimer <= 0) combo = 0;
  }

  // Spawn obstacles
  const spawnRate = Math.max(50 - difficulty * 6, 14);
  if (frameCount % Math.floor(spawnRate) === 0) {
    spawnAsteroid();
  }
  // Extra asteroids at higher difficulty
  if (difficulty > 2 && frameCount % Math.floor(spawnRate * 1.5) === 0) {
    spawnAsteroid();
  }

  // Spawn rivals
  if (frameCount % Math.max(Math.floor(120 - difficulty * 10), 40) === 0) {
    spawnRival();
  }

  // Spawn energy
  if (frameCount % 140 === 0 && Math.random() < 0.7) {
    spawnEnergy();
  }

  // Update stars
  for (let layer = 0; layer < 3; layer++) {
    starLayers[layer].forEach(star => {
      star.y += starSpeeds[layer] * (speed * 0.3 + 0.5);
      if (star.y > H + 5) {
        star.y = -5;
        star.x = Math.random() * W;
      }
    });
  }

  // Update nebulae
  nebulae.forEach(n => {
    n.y += speed * 0.15;
    if (n.y > H + n.r) {
      n.y = -n.r;
      n.x = Math.random() * W;
      n.hue = Math.random() * 360;
    }
  });

  // Update obstacles
  obstacles.forEach(o => {
    o.y += o.speed + speed * 0.7;
    o.rot += o.rotSpeed;
  });
  obstacles = obstacles.filter(o => o.y < H + 60);

  // Update rivals
  rivalShips.forEach(r => {
    r.y += r.speed + speed * 0.6;
    r.sway += 0.03;
    r.x = lanes[r.lane] + Math.sin(r.sway) * r.swayAmt;
  });
  rivalShips = rivalShips.filter(r => r.y < H + 80);

  // Update energy orbs
  energyOrbs.forEach(o => {
    o.y += speed * 0.7 + 1;
    o.pulse += 0.08;
  });
  energyOrbs = energyOrbs.filter(o => o.y < H + 40);

  // Update space debris
  spaceDebris.forEach(d => {
    d.y += speed * 0.25;
    d.rot += d.rotSpeed;
    if (d.y > H + 20) {
      d.y = -20;
      d.x = Math.random() * W;
    }
  });

  // Collision: asteroids
  if (invincibleTimer <= 0) {
    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i];
      const dx = player.x - o.x;
      const dy = player.y - o.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const hitDist = (player.w + o.size) * 0.45;
      if (dist < hitDist) {
        // Break asteroid
        addParticle(o.x, o.y, o.color, 12, { spread: 8 });
        addParticle(o.x, o.y, '#ffaa00', 6, { spread: 5, glow: true });
        obstacles.splice(i, 1);
        hitObstacle();
        break;
      }
    }
  }

  // Collision: rivals
  if (invincibleTimer <= 0) {
    for (let i = rivalShips.length - 1; i >= 0; i--) {
      const r = rivalShips[i];
      if (Math.abs(player.x - r.x) < (player.w + r.w) / 2 - 4 &&
          Math.abs(player.y - r.y) < (player.h + r.h) / 2 - 4) {
        addParticle(r.x, r.y, r.colors.main, 15, { spread: 10 });
        addParticle(r.x, r.y, '#ffcc00', 8, { spread: 6, glow: true });
        rivalShips.splice(i, 1);
        hitObstacle();
        break;
      }
    }
  }

  // Collision: energy orbs
  for (let i = energyOrbs.length - 1; i >= 0; i--) {
    const o = energyOrbs[i];
    const dx = player.x - o.x;
    const dy = player.y - o.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < player.w * 0.6 + o.size) {
      energyOrbs.splice(i, 1);

      if (o.type === 'energy') {
        combo++;
        comboTimer = 180;
        const bonus = 100 * combo;
        score += bonus;
        addParticle(o.x, o.y, '#00ff88', 10, { spread: 6, glow: true });
        addTextPopup(o.x, o.y, `+${bonus}`, '#00ff88');
      } else if (o.type === 'shield') {
        shield = Math.min(shield + 1, 5);
        addParticle(o.x, o.y, '#00ccff', 12, { spread: 8, glow: true });
        addTextPopup(o.x, o.y, '+SHIELD', '#00ccff');
        flashTimer = 5;
        flashColor = '#0088ff';
      } else {
        boostFuel = Math.min(boostFuel + 40, 100);
        addParticle(o.x, o.y, '#ff8800', 10, { spread: 6, glow: true });
        addTextPopup(o.x, o.y, '+BOOST', '#ff8800');
      }
    }
  }

  // Passed rival bonus
  rivalShips.forEach(r => {
    if (!r.passed && r.y > player.y + player.h) {
      r.passed = true;
      score += 15;
      addTextPopup(r.x, r.y, '+15', '#ffcc00');
    }
  });

  // Passed asteroid bonus
  obstacles.forEach(o => {
    if (!o.passed && o.y > player.y + player.h / 2 + o.size) {
      o.passed = true;
      score += 5;
    }
  });

  // Update particles
  particles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.95;
    p.vy *= 0.95;
    p.life--;
    p.size *= 0.97;
  });
  particles = particles.filter(p => p.life > 0);

  // Update text popups
  textPopups.forEach(t => t.life--);
  textPopups = textPopups.filter(t => t.life > 0);

  // Timers
  if (shakeTimer > 0) shakeTimer--;
  if (flashTimer > 0) flashTimer--;
  if (invincibleTimer > 0) invincibleTimer--;

  // HUD
  scoreVal.textContent = score;
  speedVal.textContent = Math.floor(speed * 20);
  const shieldBlocks = '█'.repeat(shield) + '░'.repeat(Math.max(0, 5 - shield));
  shieldVal.textContent = shieldBlocks;
  shieldVal.style.color = shield <= 1 ? '#ff3344' : (shield <= 2 ? '#ffcc00' : '#00ccff');
  boostBarFill.style.width = `${boostFuel}%`;
  boostBarFill.style.background = boosting
    ? 'linear-gradient(90deg, #ff0000, #ff4400, #ff8800)'
    : 'linear-gradient(90deg, #ff4400, #ff8800, #ffcc00)';
}

function draw() {
  ctx.save();

  // Screen shake
  if (shakeTimer > 0) {
    const intensity = shakeTimer * 0.6;
    ctx.translate(
      (Math.random() - 0.5) * intensity * 2,
      (Math.random() - 0.5) * intensity * 2
    );
  }

  // Clear to deep space
  ctx.fillStyle = '#020408';
  ctx.fillRect(-10, -10, W + 20, H + 20);

  // Nebulae (background)
  drawNebulae();

  // Stars
  drawStarfield();

  // Space debris
  drawSpaceDebris();

  // Track
  drawTrack();

  // Warp speed lines
  drawWarpLines();

  // Energy orbs
  energyOrbs.forEach(o => drawEnergyOrb(o));

  // Asteroids
  obstacles.forEach(o => drawAsteroid(o));

  // Rival ships
  rivalShips.forEach(r => {
    drawShip(r.x, r.y, r.w, r.h, r.colors, false, 0);
  });

  // Player (blink when invincible)
  if (invincibleTimer <= 0 || Math.floor(invincibleTimer / 4) % 2 === 0) {
    drawShip(player.x, player.y, player.w, player.h, null, true, player.tilt);
  }

  // Particles
  drawParticles();
  drawTextPopups();

  // Flash effect
  if (flashTimer > 0) {
    const alpha = flashTimer * 0.04;
    ctx.fillStyle = flashColor === '#0088ff'
      ? `rgba(0,136,255,${alpha})`
      : `rgba(255,0,0,${alpha})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Boost blur edge effect
  if (boosting) {
    const boostAlpha = 0.08 + Math.sin(frameCount * 0.3) * 0.03;
    const edgeGrad = ctx.createLinearGradient(0, 0, 0, H);
    edgeGrad.addColorStop(0, `rgba(255,100,0,${boostAlpha})`);
    edgeGrad.addColorStop(0.5, 'rgba(255,100,0,0)');
    edgeGrad.addColorStop(1, `rgba(255,100,0,${boostAlpha * 0.5})`);
    ctx.fillStyle = edgeGrad;
    ctx.fillRect(0, 0, 30, H);
    ctx.fillRect(W - 30, 0, 30, H);
  }

  // Minimap
  drawMinimap();

  // Combo
  drawCombo();

  // Distance
  drawDistanceCounter();

  // CRT-style scanlines (subtle)
  ctx.fillStyle = 'rgba(0,0,0,0.04)';
  for (let sy = 0; sy < H; sy += 3) {
    ctx.fillRect(0, sy, W, 1);
  }

  // Vignette
  const vig = ctx.createRadialGradient(W / 2, H / 2, W * 0.35, W / 2, H / 2, W * 0.8);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);

  ctx.restore();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// Start
startBtn.addEventListener('click', () => {
  resetGame();
  state = 'playing';
  overlay.classList.add('hidden');
});

gameLoop();
</script>
</body>
</html>
